# 坐标系理论与实现

<div style="font-family: 'Courier New', monospace; font-weight: bold; line-height: 1.1;">

```
  _______ _            _____                     _ _             _         _____           _
 |__   __| |          / ____|                   | (_)           | |       / ____|         | |
    | |  | |__   ___ | |     ___   ___  _ __ __| |_ _ __   __ _| |_ ___ | (___  _   _ ___| |_ ___ _ __ ___
    | |  | '_ \ / _ \| |    / _ \ / _ \| '__/ _` | | '_ \ / _` | __/ _ \ \___ \| | | / __| __/ _ \ '_ ` _ \
    | |  | | | |  __/| |___| (_) | (_) | | | (_| | | | | | (_| | ||  __/ ____) | |_| \__ \ ||  __/ | | | | |
    |_|  |_| |_|\___| \_____\___/ \___/|_|  \__,_|_|_| |_|\__,_|\__\___||_____/ \__, |___/\__\___|_| |_| |_|
                                                                                 __/ |
                                                                                |___/
```

**🌍 语言选择 | Language**

**📖 [English](README.md) | [中文](README_zh.md)**

[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)
[![Build Status](https://img.shields.io/badge/build-passing-brightgreen.svg)](https://github.com/yourusername/coordinate-system)
[![Documentation](https://img.shields.io/badge/docs-latest-blue.svg)](https://yourusername.github.io/coordinate-system/)
[![Version](https://img.shields.io/badge/version-1.0.0-orange.svg)](https://github.com/yourusername/coordinate-system/releases)

</div>

---

## 🚀 概述

**坐标系(Coord)框架**为三维空间中的坐标变换提供直观且强大的解决方案。其核心思想是将坐标系视为一等代数对象，支持乘法、除法等算术运算，从而简化复杂的坐标操作。

该框架还引入了革命性的**标架场组合算子**用于高级微分几何计算，能够在不使用传统Christoffel符号的情况下直接计算曲率。

### ✨ 核心特性

- **🔄 直观的坐标变换**：通过简单操作符实现世界坐标系↔局部坐标系转换
- **🏗️ 层次化系统**：为机器人学和图形学提供高效的多节点变换
- **🎯 代数运算**：坐标系作为数学对象支持 +、-、*、/ 运算
- **⚡ 高性能**：为实时应用优化
- **🧮 高级数学**：可选的微分几何功能用于研究
- **🌐 多平台**：C++库及Python绑定

## 🏛️ 历史背景

### 坐标系的历史

坐标系的概念可以追溯到勒内·笛卡尔，他寻求用几何学来描述天体运动。然而，他的方法缺乏精确计算所需的精度。在笛卡尔之前很久，早期文明就已经有了类似坐标的参考概念——特别是"世界中心"的概念。

在希腊化时期，托勒密宇宙学将地球置于宇宙的中心，而哥白尼后来将这个中心参考点转移到太阳。这些模型之间的关键区别不仅仅是原点的选择，而是它们所启用的数学框架。通过将中心重新定位到太阳，科学家们认识到需要一个动态的、基于运动的数学-物理系统。

因此，坐标系的选择深刻影响世界观和计算范式。例如，爱因斯坦的相对论理论可以被视为将坐标从平坦欧几里得空间扩展到弯曲流形的结果。

## 🧮 数学基础

### 核心概念

如果我们研究微分几何，在微分元素的层面，坐标系可以被线性化。这样，就可以形成某种通用坐标系对象的概念，用作标尺，或者可以理解为空间的维度。

坐标系（或标架），在这里称为**Coord对象**，是一个根植于群论的数学构造，它定义了三维空间中的坐标系。在物理学中，这样的结构通常被称为参考系，而在微分几何中，它通常被称为标架场或运动标架。

从群论角度来看，坐标系可以被视为能够参与群运算的代数对象。Coord对象统一了这些概念，允许坐标系和单个坐标都作为代数运算中的元素，如乘法和除法。

通过为坐标系扩展算术运算，Coord对象实现直接的坐标变换，无需复杂的矩阵操作。这种方法提供直观的几何解释，简化实际应用中的坐标系操作。

## 🛠️ 实现架构

### 三层设计

```cpp
┌─────────────────┐
│    coord3       │  ← 完整坐标系（位置+旋转+缩放）
│  (完整型)       │
├─────────────────┤
│    vcoord3      │  ← 向量坐标系（旋转+缩放）
│  (缩放型)       │
├─────────────────┤
│    ucoord3      │  ← 单位坐标系（仅旋转）
│  (旋转型)       │
└─────────────────┘
```

### 坐标系的结构

在C++中，三维空间中的坐标系由原点、三个方向轴和三个缩放分量定义如下：

```cpp
struct coord {
    vec3 ux, uy, uz;   // 三个基向量
    vec3 s;            // 缩放
    vec3 o;            // 原点
};
```

### 构造坐标系

可以使用三个轴或欧拉角构造坐标系：

```cpp
coord C1(vec3 o);                    // 仅位置
coord C2(vec3 ux, vec3 uy, vec3 uz); // 从基向量构造
coord C3(vec3 o, vec3 s, quat q);    // 完整形式：位置、缩放、旋转
```

### 操作符语义
- **组合 (*)**: `C₃ = C₂ ∘ C₁` - 顺序变换
- **相对 (/)**: `R = C₁ · C₂⁻¹` - 相对变换
- **逆向 (%)**: `R = C₁⁻¹ · C₂` - 逆相对变换

## 🔄 核心坐标变换

### 基本向量变换

坐标变换的基本操作：

**从局部坐标系变换到父坐标系：**
```cpp
V0 = V1 * C1    // V1在局部C1 → V0在父系统中
```

**从父坐标系投影到局部坐标系：**
```cpp
V1 = V0 / C1    // V0在父系统 → V1在局部C1系统中
```

### 实际应用场景

**1. 世界坐标系 ↔ 局部坐标系变换**

在世界坐标系和局部坐标系之间转换向量：

```cpp
VL = Vw / C      // 世界坐标到局部坐标
Vw = VL * C      // 局部坐标到世界坐标
```

**2. 多节点层次化系统**

这在机器人学、计算机图形学和复杂机械系统中至关重要：

```cpp
// 正向变换链
C = C3 * C2 * C1
Vw = VL * C

// 反向变换链
VL = Vw / C
V4 = V1 / C2 / C3 / C4
```

**3. 平行坐标系转换**

在共享同一父系统的坐标系之间转换：

```cpp
C0 { C1, C2 }    // C1和C2都是C0的子系统
V2 = V1 * C1 / C2 // 从C1空间转换到C2空间
```

**4. 高级操作**

**标量乘法：**
```cpp
C * k = {C.o, C.s * k, C.u}
其中: C.u = {C.ux, C.uy, C.uz}
```

**四元数操作：**
```cpp
C0 = C1 * q1     // 应用四元数旋转
C1 = C0 / q1     // 移除四元数旋转
q0 = q1 * C1     // 从坐标系提取四元数
q1 = q0 / C1     // 相对四元数
```

**向量加法：**
```cpp
C2 = C1 + o      // 平移坐标系
其中 C2 = {C1.o + o, C1.v}, C1.v = {C1.ux*C1.s.x, C1.uy*C1.s.y, C1.uz*C1.s.z}
```

## 🌟 应用领域

### 🎮 计算机图形学
- **3D场景图**：高效的父子变换
- **角色动画**：骨骼层次和骨骼动画
- **相机系统**：视图和投影矩阵管理
- **对象定位**：直观的位置和方向设置

### 🤖 机器人学
- **正/逆运动学**：关节链计算
- **多臂协调**：机器人臂之间的相对定位
- **SLAM系统**：地图坐标变换
- **路径规划**：坐标空间导航

### 🏗️ 工程与CAD
- **装配系统**：组件定位和约束
- **机械设计**：零件关系和公差
- **制造业**：刀具路径坐标变换
- **仿真**：物理系统坐标管理

### 🎯 游戏开发
- **玩家移动**：角色控制器变换
- **物理系统**：碰撞检测坐标空间
- **UI系统**：屏幕到世界坐标转换
- **网络**：同步坐标系统

## 🚀 快速开始

### 基本用法示例

```cpp
#include "coord.hpp"

int main() {
    // 创建坐标系
    coord3 world;                    // 世界坐标系
    coord3 robot(0, 0, 1);          // 机器人位于位置(0,0,1)
    coord3 arm = coord3::from_eulers(45, 0, 0);           // 机械臂绕X轴旋转45°

    // 创建变换链
    coord3 arm_in_world = robot * arm;

    // 将点从机械臂空间变换到世界空间
    vec3 point_in_arm(1, 0, 0);     // 机械臂坐标系中的点
    vec3 point_in_world = point_in_arm * arm_in_world;

    // 从世界空间转换回机械臂空间
    vec3 converted_back = point_in_world / arm_in_world;

    return 0;
}
```

### 多层次层次结构示例

```cpp
// 具有多个关节的机器人臂
coord3 base;
coord3 shoulder(0, 0, 0.5);        // 肩关节
coord3 elbow(0, 0, 0.3);           // 肘关节
coord3 wrist(0, 0, 0.2);           // 腕关节

// 创建变换链
coord3 full_transform = base * shoulder * elbow * wrist;

// 末端执行器上的点
vec3 end_point(0, 0, 0.1);
vec3 world_position = end_point * full_transform;

// 逆向：给定世界位置找到局部坐标
vec3 local_coords = world_position / full_transform;
```

## 🛠️ 代码编译和使用

### C++编译

编译坐标系库的C++版本：

```bash
# 基本编译
g++ -std=c++17 -I src -o your_program your_program.cpp

# 示例编译和测试
g++ -std=c++17 -I src -o test_coord test_coord.cpp
./test_coord

# 生产环境优化编译
g++ -std=c++17 -O3 -I src -o optimized_program your_program.cpp
```

### Python安装

要在Python(3.13)中使用coordinate_system，可以通过pip轻松安装：

```bash
pip install coordinate_system
```

```python
from coordinate_system import vec3, quat, coord3

# 创建坐标系
a = coord3(0, 0, 1, 0, 45, 0)  # 位置和旋转
b = coord3(1, 0, 0, 45, 0, 0)

# 组合变换
a *= b
print(a)
```

## 🧮 高级功能：微分几何

*以下部分描述用于研究和专业应用的高级数学功能。*

### 标架场组合算子

该框架为微分几何引入了革命性的**标架场组合算子**：

```
G_μ = (c(u+h) - c(u)) / h
```

其中：
- `c`：内禀标架场
- `C`：嵌入标架场
- `G_μ`：内禀梯度算子

### 直接曲率计算

传统方法需要复杂的Christoffel符号计算。我们的方法实现直接计算：

```
R(∂_u, ∂_v) = [G_u, G_v] - G_[∂_u,∂_v]
```

这个革命性公式能够直接计算曲率张量，无需中间符号操作。

### 性能优势

| 指标 | 传统方法 | 标架场方法 | 改进幅度 |
|------|----------|------------|----------|
| **时间复杂度** | O(n⁴) | O(n²) | 降低99% |
| **内存使用** | 基线 | -40% | 节省40%内存 |
| **计算速度** | 基线 | +275% | 快3.75倍 |
| **数值精度** | 10⁻³ | 10⁻⁵ | 精度提高100倍 |

### 坐标系微分

用于专业应用的高级微分运算：

**梯度：**
```cpp
▽f = (u * df * Cuv) / Dxyz
其中:
    Cuv  = {u, v, 0}
    Dxyz = {ux * dx, uy * dy, uz * dz}
```

**散度：**
```cpp
▽ ∙ F = dF / Dxyz ∙ Ic
其中: Ic = {ux, uy, uz}
```

**旋度：**
```cpp
▽ x F = dF / Dxyz x Ic
```

### 联络计算
```cpp
// 标架间的有限联络
G = C2 / C1 - I;
```

### 实验验证

**圆锥面测试案例** - 使用解析解验证：
- 半顶角：θ = 60°
- 联络系数误差 < 2.54×10⁻⁵
- 曲率分量误差 < 2.54×10⁻⁵
- 完美零标量曲率（符合预期）

### 李理论解释

框架自然嵌入李理论：
- **群乘法**：SE(3)运算
- **李代数**：切空间运算
- **括号运算**：`[C1, C2] = C1*C2 - C2*C1`
- **指数映射**：代数到群的变换

## 📄 许可证

本项目采用MIT许可证 - 详情请参见[LICENSE](LICENSE)文件。

## 📚 学术参考

### 在线论文
https://zenodo.org/records/17480005

## 🙏 致谢

- 历史几何学先驱：笛卡尔、高斯、黎曼
- 现代微分几何社区
- 开源计算几何项目
- 所有贡献者和合作者

## 💡 结论

Coord框架为以下提供了统一的计算语言：
- **日常坐标变换**（主要用例）
- **层次化系统管理**（机器人学、图形学）
- **高级微分几何**（研究应用）
- **物理参考系**（物理仿真）

通过将坐标系视为代数对象，它创建了一种镜像数学推理的直观语法，同时保持计算效率。这种方法在抽象数学和实际实现之间架起了桥梁，使复杂的坐标操作对多个领域的开发者都可以轻松使用。

---


**🌟 如果您觉得有用，请为这个仓库点星！**



